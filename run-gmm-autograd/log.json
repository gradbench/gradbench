[
  {
    "message": {"id": 0, "kind": "define", "module": "gmm", "source": "import \"array\" use\n  array,\n  concat,\n  for,\n  map,\n  matrix,\n  max,\n  range,\n  reshape,\n  row,\n  scan,\n  slice,\n  stack,\n  sum,\n  transpose,\n  zeros,\nimport \"math\" use exp, float, int, lgamma, log, pi, sqr, sqrt\n\ndef logsumexp[K](x: [K]Float): Float =\n  let mx = max(x)\n  let emx = exp.(for i => x[i] - mx)\n  log(sum(emx) + mx)\n\ndef logsumexpvec[K, N](x: [N * K]Float): [N]Float =\n  for i => logsumexp(row(x, i))\n\ndef log_gamma_distrib(a: Float, p: Int): Float =\n  let out = (let p = float(p); 0.25 * p * (p - 1.0) * log(pi))\n  out + sum(map(range(p), i =>\n    let j = i + 1\n    lgamma(a + 0.5 * float(1 - j))\n  ))\n\ndef log_wishart_prior[D, K]({\n  p: Int,\n  wishart_gamma: Float,\n  wishart_m: Int,\n  sum_qs: [K]Float,\n  qdiags: [K * D]Float,\n  ls: [K * D * D]Float,\n}): Float =\n  let n = p + wishart_m + 1\n  let k = int[K]()\n\n  let out = sum(\n    0.5\n    * wishart_gamma\n    * wishart_gamma\n    * (for i => sum(sqr.(row(qdiags, i))) + sum(sqr.(row(ls, i))))\n    - float(wishart_m) * sum_qs\n  )\n\n  let c = float(n * p) * log(wishart_gamma / sqrt(2.0))\n  out - float(k) * (c - log_gamma_distrib(0.5 * float(n), p))\n\ndef construct_l[D](icf: []Float): [D * D]Float =\n  let d = int[D]()\n  let cols = scan(\n    (d, zeros[D]()), range(d - 1),\n    ((j, _), i) =>\n      let k = i + 1\n      index K <- k\n      let n = d - k\n      j + n, reshape(concat(zeros[K](), slice(icf, j, j + n)))\n  )\n  transpose(stack(reshape(map(cols, (_, v) => v))))\n\ndef qtimesx[D, K, N]({\n  qdiag: [K * D]Float,\n  l: [K * D * D]Float,\n  x: [N * K * D]Float,\n}): [N * K * D]Float =\n  let f = for (m, i, j) => sum(for k => l[i, j, k] * x[m, i, k])\n  stack(for i => qdiag .* row(x, i)) + f\n\ndef gmm_objective[D, K, N]({\n  alphas: [K]Float,\n  means: [K * D]Float,\n  qs: [K * D]Float,\n  ls: [K * D * D]Float,\n  x: [N * D]Float,\n  wishart_gamma: Float,\n  wishart_m: Int,\n}): Float =\n  let n = int[N]()\n  let d = int[D]()\n\n  let qdiags = exp.(qs)\n  let sum_qs = for i => sum(for j => qs[i, j])\n\n  let xcentered = reshape[N * K * D](\n    stack(for (i, j) => row(x, i) - row(means, j))\n  )\n  let lxcentered = qtimesx({qdiag = qdiags, l = ls, x = xcentered})\n  let sqsum_lxcentered = for (i, j) => sum(for k => sqr(lxcentered[i, j, k]))\n  let inner_term = stack(for i =>\n    alphas + sum_qs - 0.5 * row(sqsum_lxcentered, i)\n  )\n  let lse = logsumexpvec(inner_term)\n  let slse = sum(lse)\n\n  let constant = float(-n * d) * 0.5 * log(2.0 * pi)\n  (\n    constant\n    + slse\n    - float(n) * logsumexp(alphas)\n    + log_wishart_prior({\n      p = d,\n      wishart_gamma,\n      wishart_m,\n      sum_qs,\n      qdiags,\n      ls,\n    })\n  )\n\ndef gmm({\n  d: Int,\n  k: Int,\n  n: Int,\n  alpha: []Float,\n  means: [][]Float,\n  icf: [][]Float,\n  x: [][]Float,\n  gamma: Float,\n  m: Int,\n}): Float =\n  index D <- d\n  index K <- k\n  index N <- n\n  gmm_objective[D, K, N]({\n    alphas = array(alpha),\n    means = matrix(means),\n    qs = matrix(map(icf, curr_icf => slice(curr_icf, 0, d))),\n    ls = stack(reshape(map(icf, curr_icf => construct_l(curr_icf)))),\n    x = matrix(x),\n    wishart_gamma = gamma,\n    wishart_m = m,\n  })\n"},
    "nanoseconds": 483432,
    "response": {"id": 0, "success": false}
  },
  {
    "message": {"id": 1, "kind": "end", "validations": []}
  }
]
